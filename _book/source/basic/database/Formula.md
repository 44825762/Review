### 数据库四大范式
---
##### 满足范式要求的数据库设计是结构清晰的，同时可避免数据冗余和操作异常。这并意味着不符合范式要求的设计一定是错误的，在数据库表中存在1：1或1：N关系这种较特殊的情况下，合并导致的不符合范式要求反而是合理的。
---
###### 第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式
---
数据库的设计范式是数据库设计所需要满足的规范，满足这些规范的数据库是简洁的、结构明晰的，同时，不会发生插入（insert）、删除（delete）和更新（update）操作异常。

1. 第一范式（1NF）：数据库表中的字段都是单一属性的，不可再分。确保每列保持原子性

    第一范式的合理遵循需要根据系统的实际需求来定。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式，如下表所示。

    ![第一范式](https://user-gold-cdn.xitu.io/2020/5/8/171f37c81b0162ea?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
    
    上表所示的用户信息遵循了第一范式的要求，这样在对用户使用城市进行分类的时候就非常方便，也提高了数据库的性能。

2. 第二范式（2NF）：确保表中的每列都和主键相关

    第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。
    
    比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键，如下表所示。
    
    ![第二范式1](https://user-gold-cdn.xitu.io/2020/5/8/171f37cb86635c09?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
    
    这样就产生一个问题：这个表中是以订单编号和商品编号作为联合主键。这样在该表中商品名称、单位、商品价格等信息不与该表的主键相关，而仅仅是与商品编号相关。所以在这里违反了第二范式的设计原则。
    
    而如果把这个订单信息表进行拆分，把商品信息分离到另一个表中，把订单项目表也分离到另一个表中，就非常完美了。如下所示。

    ![第二范式2](https://user-gold-cdn.xitu.io/2020/5/8/171f37cf512e9e85?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
    
    这样设计，在很大程度上减小了数据库的冗余。如果要获取订单的商品信息，使用商品编号到商品信息表中查询即可。

3. 第三范式（3NF）：确保每列都和主键列直接相关,而不是间接相关。

    第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。
    
    比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。如下面这两个表所示的设计就是一个满足第三范式的数据库表。
    
    ![第三范式](https://user-gold-cdn.xitu.io/2020/5/8/171f37d4444ab654?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

    这样在查询订单信息的时候，就可以使用客户编号来引用客户信息表中的记录，也不必在订单信息表中多次输入客户信息的内容，减小了数据冗余。

4. 鲍依斯-科得范式（BCNF）：在第三范式的基础上，数据库表中如果不存在任何字段对任一候选关键字段的传递函数依赖则符BCNF范式。
    
    Boyce-Codd Normal Form。没有新的规范加入，是对第二范式和第三范式的一个加强。

    1. 所有的非主属性对每一个码都是完全函数依赖 （暗含 主关键字里面可能有多个码可以将实体区分）
    2. 所有的主属性对每一个不包含它的码也是完全函数依赖（即所选码与未选择的码之间也是完全函数依赖的）
    3. 没有任何属性完全函数依赖于非码的任何一组属性（即非主属性之间不能函数依赖）
    
    解释：
    例如关系模式 S(Sno,Sname,Sdept,Sage) 假设 Sname具有唯一性
    解释条件1：非主属性 （Sdept,Sage） 不仅依赖于Sno,而且依赖于Sname,因为不仅可以通过学号知道学生的信息，还可以通过姓名知道学生的信息。
    解释条件2：Sno 与Sname之间也是完全函数依赖关系
    解释条件3：没有任何一个属性函数依赖于Sdept和Sage















